\section{Vertical Split Encoding for N-tuple Networks}

Nタプルネットワーク
2048 の強いコンピュータプレイヤを作る最も成功した方法は，N タプルネットワークによる評価関数を強化学習によりチューニングするものである。Nタプルネットワークは，盤面の (局所的な) サンプリングとlook-up tableによる評価関数の近似関数である．各N-tupleに対して該当する場所の値をサンプリング・look-up tableから局所評価値を取得し，それら局所評価値を足し合わせることで全体の評価関数を得る．2048では，盤面の対称性から，一つのNタプルに対して8通りのサンプリングを行うことが一般的であり，本研究でもその対称性の利用を採用する．

ニューラルネットワークと比べて，Nタプルネットワークは高速に評価値を計算することができるものの，一般に必要となるメモリ量が多い．盤面の各セルのとりうる値が $x$ 種類，タプルの数が m，タプルの大きさが n であるとき，look-up table は $m \times x^n$ 要素からなる．2048では，$\mbox{empty}, 2^1, 2^2, \ldots, 2^17$ の$x=18$通りの値をとりうるため，$n$ を増やしたときに必要となるメモリが問題となってしまう．実際，Jaskowski は，(multi-staging を採用できない)7タプルに拡大するよりも，6タプルとmulti-staging を組合せることが有用だと実験で示した．

しかしながら，タプルサイズを増やすことができれば，大きな性能向上が見込まれる．Matsuzaki は，6タプルと7タプルの組合せとプレイヤの性能の関係を調べ，7タプルのほうが性能が優れていた．しかし，上述のメモリサイズの問題が発生する．
Nタプルの大きさを 6～9 としたとき，1つのN-tuple に対してlook-up テーブルに必要となるパラメータ数，現在主流となっている Multi-staging と Temoral Coherence 学習を組み合わせた場合のメモリ量を表\ref{table:NTupleMemory}にまとめる．
一般は，4個以上のN-tuple を組み合わせて用いるので，commodity computer (e.g. computer with 64GB メモリ) では 7-tuple 以上を実現することができないと考えられていた．
\begin{table}
\setlength{\doublerulesep}{.4pt}
 \caption{Number of parameters and required memory size.  In the calculation of memory size, We assume an implementation of temporal coherence learning with 2 stages and 64 bits per element.}
\label{table:NTupleMemory}
 \begin{tabular}{l|rr}
\hline\hline
  size & parameters & memory \\
\hline
  $1 \times 6$-tuple & 34\,012\,224 & 1.5 GB \\
  $1 \times 7$-tuple & 612\,220\,032 & 27.4 GB \\
  $1 \times 8$-tuple & 11\,019\,960\,576 & 492.6 GB \\
  $1 \times 9$-tuple & 198\,359\,290\,368 & 8\,867.4 GB \\
\hline
% (*    18 18 18 18 18 18 18 18 18)
% (/ (* 18 18 18 18 18 18 18 18 18 8 3 2) 1024.0 1024.0 1024.0)
 \end{tabular}
\end{table}

このメモリサイズの問題を解決し，大規模タプルを効率的に扱うための新手法として，本研究では Vertical Split Encoding (VSE) を提案する．上述のとおり，メモリサイズがとても大きくなる理由は，盤面の取り得る値の種類 $x=18$ が大きいからである．一方で，著者らは2048における次の特徴に着目した．
- 値の近いタイルの間の位置関係は重要である
- 値の遠いタイルは相互作用しない
- 空白マスの位置は重要である．
これらの特徴のうち，2つ目の特徴から，ある値のタイルに着目すると，それと値が大きく離れたタイルは区別する必要がないことを示唆する．例えば，値が 2 (= $2^1$) のタイルに着目すると，その周辺にある値 $2048 = 2^{11}$ や $4096 = 2^{12}$ を区別するのはほとんど意味をなささい．したがって，そのような値が大きく離れたタイルを同一視することで，パラメータ数を減らすことができると考えた．

この考えに基づき，Vertical Split Encoding は，盤面を，いくつかの値を同一視した複数の盤面にエンコードする．
各エンコードでは，着目したい値の範囲を value range とし，その範囲より小さい・大きい値はすべて S・L に置き換える．
ただし，上で述べた2048の特徴の3より，empty cell (E) については特別扱いする．
図に具体例を示す．ここでは，value ranges は 1--10 と 11-17 とする．
このとき，一つ目のエンコードでは，$2^{11}$～$2^{17}$の値を持つタイルはすべて L となり，2つ目のエンコードでは
$2^{1}$～$2^{10}$ のタイルはすべて S となる．これにより，1つ目のエンコードについては，各セルのとりうる値が $x_1 = 1 + 10 + 1 = 12$ 通り，2つ目のエンコーディングでは $x_2 = 1 + 1 + 7 = 9$ 通りとなり，look-up table の要素数を大きく減少させられる．

後述する2048に対する実験では，7タプル，8タプル，9タプルに対し，それぞれ，2つ，3つ，4つのvalue ranges からなるVSEを適用し，プレイヤの性能を評価する．
